---
# Shared E2E Task definition
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: e2e-task
spec:
  params:
    - description: The Trusted Artifact URI containing the application to test
      name: SOURCE_ARTIFACT
      type: string
    - description: The script to execute the e2e tests
      name: e2e-tests-script
      type: string
    - description: HTTP proxy configuration
      name: HTTP_PROXY
      type: string
    - description: Test user credentials
      name: E2E_USER
      type: string
    - description: Test user password
      name: E2E_PASSWORD
      type: string
    - description: Proxy routes configuration (Caddy directives)
      name: PROXY_ROUTES
      type: string
      default: |
        handle /index.html {
            reverse_proxy http://localhost:9912
        }

        handle /apps/chrome* {
            reverse_proxy http://localhost:9912
        }
    - description: Test application caddyfile config
      name: APP_CADDY_CONFIG
      type: string
    - description: Application port (default 8000)
      name: APP_PORT
      type: string
      default: "8000"
    - description: Playwright image to use for testing
      name: PLAYWRIGHT_IMAGE
      type: string
      default: "mcr.microsoft.com/playwright:v1.50.0-noble"
    - description: Chrome dev image
      name: CHROME_DEV_IMAGE
      type: string
      default: "quay.io/redhat-services-prod/hcc-platex-services-tenant/insights-chrome-dev:latest"
    - description: Frontend proxy image
      name: PROXY_IMAGE
      type: string
      default: "quay.io/redhat-user-workloads/hcc-platex-services-tenant/frontend-development-proxy:latest"
    - description: Actual stage environment hostname (for catch-all proxy)
      name: STAGE_ACTUAL_HOSTNAME
      type: string
    - description: HCC environment URL
      name: HCC_ENV_URL
      type: string
    - description: HCC env shortname
      name: HCC_ENV
      type: string
      default: "stage"
  sidecars:
    - image: $(params.PROXY_IMAGE)
      name: frontend-dev-proxy
      command: ["/bin/sh", "-c"]
      args:
        - |
              #!/bin/sh
              echo "Waiting for /config/routes to be available..."
              timeout=60
              elapsed=0
              while [ ! -f /config/routes ] && [ $elapsed -lt $timeout ]; do
                echo "Config file not found, waiting... ($elapsed/$timeout seconds)"
                sleep 2
                elapsed=$((elapsed + 2))
              done

              if [ ! -f /config/routes ]; then
                echo "ERROR: /config/routes not found after ${timeout} seconds"
                exit 1
              fi

              echo "Config file found!"
              echo "Routes content:"
              cat /config/routes

              # Export LOCAL_ROUTES environment variable from the file
              export LOCAL_ROUTES="$(cat /config/routes)"
              echo "LOCAL_ROUTES environment variable set"

              # Check if Caddyfile exists and contains {$LOCAL_ROUTES} placeholder
              echo "Checking for LOCAL_ROUTES placeholder in Caddyfile..."
              if [ ! -f /etc/caddy/Caddyfile ]; then
                echo "ERROR: /etc/caddy/Caddyfile not found!"
                exit 1
              fi

              if ! grep -q '{$LOCAL_ROUTES}' /etc/caddy/Caddyfile; then
                echo "ERROR: {$LOCAL_ROUTES} placeholder not found in Caddyfile!"
                echo "The Caddyfile must contain {$LOCAL_ROUTES} where routes should be injected."
                exit 1
              fi
          
              # Same as the default one in the fe-dev-proxy container but debug and admin are turned on
              cat << CADDY_DEF > /etc/caddy/Caddyfile
              {
                order rewrite before reverse_proxy
                order rh_identity_transform before respond
                cache
                admin :2019
                # Uncomment the line below to enable debugging
                # debug
              }
          
              stage.foo.redhat.com:$PROXY_PORT {
                log default {
                  output stdout
                  format transform "{common_log}"
                }
          
                @html_fallback {
                  header Accept *text/html*
                  not path_regexp .*\/(silent-check-sso\.html)$
                }
          
                $LOCAL_ROUTES
          
                handle {
                  cache
                  reverse_proxy $HCC_ENV_URL {
                    header_up Host {http.reverse_proxy.upstream.hostport}
                    header_up Accept-Encoding "gzip;q=0,deflate,sdch"
                    header_up -Origin
                  }
                }
                tls internal {
                  on_demand
                }
              }
              CADDY_DEF

              echo "Formatting Caddyfile"
              caddy fmt --overwrite /etc/caddy/Caddyfile
          
              echo "Updated /etc/caddy/Caddyfile follows:"
              cat /etc/caddy/Caddyfile

              # Wait for insights-chrome-dev to be ready on port 9912
              echo "Waiting for insights-chrome-dev to be ready on port 9912..."
              max_wait=60
              elapsed=0
              while [ $elapsed -lt $max_wait ]; do
                if wget -q -O /dev/null --timeout=2 http://127.0.0.1:9912 2>/dev/null; then
                  echo "insights-chrome-dev is ready!"
                  break
                fi
                echo "Waiting for insights-chrome-dev... ($elapsed/$max_wait seconds)"
                sleep 2
                elapsed=$((elapsed + 2))
              done

              if [ $elapsed -ge $max_wait ]; then
                echo "ERROR: insights-chrome-dev did not become ready after ${max_wait} seconds"
                exit 1
              fi

              # Wait for run-application to be ready on port 8000
              echo "Waiting for run-application to be ready on port 8000..."
              elapsed=0
              while [ $elapsed -lt $max_wait ]; do
                if wget -q -O /dev/null --timeout=2 http://127.0.0.1:8000 2>/dev/null; then
                  echo "run-application is ready!"
                  break
                fi
                echo "Waiting for run-application... ($elapsed/$max_wait seconds)"
                sleep 2
                elapsed=$((elapsed + 2))
              done

              if [ $elapsed -ge $max_wait ]; then
                echo "WARNING: run-application did not become ready after ${max_wait} seconds"
                exit 1
              fi

              echo "Starting frontend-development-proxy..."
              caddy run --config /etc/caddy/Caddyfile
      env:
        - name: HTTP_PROXY
          value: $(params.HTTP_PROXY)
        - name: HTTPS_PROXY
          value: $(params.HTTP_PROXY)
        - name: HCC_ENV
          value: "stage"
        - name: PROXY_PORT
          value: "1337"
        - name: HCC_ENV_URL
          value: $(params.HCC_ENV_URL)
        - name: STAGE_ACTUAL_HOSTNAME
          value: $(params.STAGE_ACTUAL_HOSTNAME)
      securityContext:
        privileged: false
      volumeMounts:
        - name: proxy-config
          mountPath: /config
    - image: $(params.CHROME_DEV_IMAGE)
      name: insights-chrome-dev
      command: ["/bin/sh", "-c"]
      args:
        - |
          #!/bin/sh
          set -e

          echo "Creating Caddyfile for insights-chrome-dev..."
          mkdir -p /etc/caddy
          cat > /etc/caddy/Caddyfile << 'EOF'
          {
            # debug
          }

          :9912 {
              root * /opt/app-root/src/build/stable

              # Handle /apps/chrome* requests - strip prefix and serve
              @app_match {
                  path /apps/chrome*
              }
              handle @app_match {
                  uri strip_prefix /apps/chrome
                  file_server {
                      browse
                  }
              }

              # Handle all other requests - try files, fallback to index.html for SPA routing
              handle {
                  try_files {path} /index.html
                  file_server
              }

              header {
                  Cache-Control "no-cache, no-store, must-revalidate"
                  Pragma "no-cache"
                  Expires "0"
              }
              header {
                  Access-Control-Allow-Origin "*"
                  Access-Control-Allow-Methods "GET, POST, OPTIONS"
                  Access-Control-Allow-Headers "Content-Type"
              }
          }
          EOF

          echo "Caddyfile created successfully:"
          cat /etc/caddy/Caddyfile

          echo "Starting caddy..."
          exec caddy run --config /etc/caddy/Caddyfile
      securityContext:
        privileged: false
      volumeMounts:
        - name: workdir
          mountPath: /var/workdir
        - name: chrome-dev-caddyfile
          mountPath: /etc/caddy
    - name: run-application
      image: $(params.SOURCE_ARTIFACT)
      command: ["/bin/sh", "-c"]
      args:
        - |
          #!/bin/sh
          set -e

          echo "Patching Caddyfile to add learning-resources routes..."

          # Create a temporary file with the new routes
          cat > /tmp/learning_resources_routes.txt << 'EOF'

          # Handle all learning-resources routes
          @learning_resources_match {
              path /learning-resources /learning-resources/
          }
          handle @learning_resources_match {
              uri strip_prefix /learning-resources
              rewrite / /index.html
              file_server * {
                  root /srv/dist
              }
          }

          @learning_resources_subpath {
              path /learning-resources/*
          }
          handle @learning_resources_subpath {
              uri strip_prefix /learning-resources
              file_server * {
                  root /srv/dist
              }
          }

          @settings_learning_resources_match {
              path /settings/learning-resources /settings/learning-resources/
          }
          handle @settings_learning_resources_match {
              uri strip_prefix /settings/learning-resources
              rewrite / /index.html
              file_server * {
                  root /srv/dist
              }
          }

          @settings_learning_resources_subpath {
              path /settings/learning-resources/*
          }
          handle @settings_learning_resources_subpath {
              uri strip_prefix /settings/learning-resources
              file_server * {
                  root /srv/dist
              }
          }

          @openshift_learning_resources_match {
              path /openshift/learning-resources /openshift/learning-resources/
          }
          handle @openshift_learning_resources_match {
              uri strip_prefix /openshift/learning-resources
              rewrite / /index.html
              file_server * {
                  root /srv/dist
              }
          }

          @openshift_learning_resources_subpath {
              path /openshift/learning-resources/*
          }
          handle @openshift_learning_resources_subpath {
              uri strip_prefix /openshift/learning-resources
              file_server * {
                  root /srv/dist
              }
          }

          @ansible_learning_resources_match {
              path /ansible/learning-resources /ansible/learning-resources/
          }
          handle @ansible_learning_resources_match {
              uri strip_prefix /ansible/learning-resources
              rewrite / /index.html
              file_server * {
                  root /srv/dist
              }
          }

          @ansible_learning_resources_subpath {
              path /ansible/learning-resources/*
          }
          handle @ansible_learning_resources_subpath {
              uri strip_prefix /ansible/learning-resources
              file_server * {
                  root /srv/dist
              }
          }

          @insights_learning_resources_match {
              path /insights/learning-resources /insights/learning-resources/
          }
          handle @insights_learning_resources_match {
              uri strip_prefix /insights/learning-resources
              rewrite / /index.html
              file_server * {
                  root /srv/dist
              }
          }

          @insights_learning_resources_subpath {
              path /insights/learning-resources/*
          }
          handle @insights_learning_resources_subpath {
              uri strip_prefix /insights/learning-resources
              file_server * {
                  root /srv/dist
              }
          }

          @edge_learning_resources_match {
              path /edge/learning-resources /edge/learning-resources/
          }
          handle @edge_learning_resources_match {
              uri strip_prefix /edge/learning-resources
              rewrite / /index.html
              file_server * {
                  root /srv/dist
              }
          }

          @edge_learning_resources_subpath {
              path /edge/learning-resources/*
          }
          handle @edge_learning_resources_subpath {
              uri strip_prefix /edge/learning-resources
              file_server * {
                  root /srv/dist
              }
          }

          @iam_learning_resources_match {
              path /iam/learning-resources /iam/learning-resources/
          }
          handle @iam_learning_resources_match {
              uri strip_prefix /iam/learning-resources
              rewrite / /index.html
              file_server * {
                  root /srv/dist
              }
          }

          @iam_learning_resources_subpath {
              path /iam/learning-resources/*
          }
          handle @iam_learning_resources_subpath {
              uri strip_prefix /iam/learning-resources
              file_server * {
                  root /srv/dist
              }
          }
          EOF

          # Use awk to insert the new routes before the "handle / {" line
          awk '
          /^[[:space:]]*handle \/ \{/ && !done {
              while ((getline line < "/tmp/learning_resources_routes.txt") > 0) {
                  print line
              }
              close("/tmp/learning_resources_routes.txt")
              done = 1
          }
          { print }
          ' /etc/caddy/Caddyfile > /tmp/Caddyfile.new

          mv /tmp/Caddyfile.new /etc/caddy/Caddyfile

          echo "Patched Caddyfile:"
          cat /etc/caddy/Caddyfile

          echo "Starting application with Caddy..."
          # Start Caddy with the patched configuration
          exec caddy run --config /etc/caddy/Caddyfile
      securityContext:
        privileged: false
      volumeMounts:
        - name: workdir
          mountPath: /var/workdir
  volumes:
    - name: workdir
      emptyDir: {}
    - name: proxy-config
      emptyDir: {}
    - name: chrome-dev-caddyfile
      emptyDir: {}
  stepTemplate:
    volumeMounts:
      - mountPath: /var/workdir
        name: workdir
        readOnly: false
  steps:
    - name: setup-proxy-routes
      image: quay.io/quay/busybox
      script: |
        #!/bin/sh
        set -e
        echo "Writing proxy routes configuration (Caddy directives)..."
        cat > /config/routes << 'EOF'
        $(params.PROXY_ROUTES)
        EOF
        chmod 644 /config/routes
        echo "Proxy routes configured successfully:"
        cat /config/routes
      volumeMounts:
        - name: proxy-config
          mountPath: /config
    - image: $(params.PLAYWRIGHT_IMAGE)
      env:
        - name: HTTP_PROXY
          value: $(params.HTTP_PROXY)
        - name: HTTPS_PROXY
          value: $(params.HTTP_PROXY)
        - name: E2E_USER
          value: $(params.E2E_USER)
        - name: E2E_PASSWORD
          value: $(params.E2E_PASSWORD)
        - name: NO_PROXY
          value: "stage.foo.redhat.com"
      name: e2e-tests
      computeResources:
        requests:
          cpu: "2000m"
          memory: "4Gi"
        limits:
          cpu: "4000m"
          memory: "8Gi"
      securityContext:
        runAsUser: 0
      script: $(params.e2e-tests-script)
  workspaces:
    - name: shared-code-workspace
      mountPath: /workspace/output
---
# Shared E2E Pipeline definition
apiVersion: tekton.dev/v1
kind: Pipeline
metadata:
  name: e2e-pipeline
spec:
  params:
    - name: branch-name
      type: string
      description: Branch within the source repository
    - name: repo-url
      type: string
      description: URL of the source repository
    - name: SOURCE_ARTIFACT
      description: URI of the trusted artifact containing the built application
    - name: e2e_proxy
      description: HTTP proxy for external requests
    - name: E2E_USER
      description: Test automation username
    - name: E2E_PASSWORD
      description: Test automation password
    - name: STAGE_ACTUAL_HOSTNAME
      type: string
      description: Actual stage environment hostname (for catch-all proxy)
    - name: HCC_ENV_URL
      type: string
      description: HCC environment URL
    - name: HCC_ENV
      type: string
      description: short name for the HCC environment url
    - name: proxy-routes
      type: string
      description: Custom proxy routes configuration (Caddy directives)
      default: |
        handle /index.html {
            reverse_proxy http://localhost:9912
        }

        handle /apps/chrome* {
            reverse_proxy http://localhost:9912
        }
    - name: e2e-tests-script
      type: string
      description: Custom test execution script
      default: |
        # TODO: Wait for stage.foo.redhat.com to be responsive
        set -x
        echo "HTTP_PROXY is ${HTTP_PROXY}"
        echo "HTTPS_PROXY is ${HTTPS_PROXY}"
        getent hosts stage.foo.redhat.com
        cd /workspace/output
        set -e
        # Uncomment the following sleep to keep the pod active for some live debugging
        # sleep 2000
        npm install
        npx playwright test
  workspaces:
    - name: shared-code-workspace
      description: Workspace for passing repo source to the test run task
  tasks:
    - name: fetch-source
      taskRef:
        name: git-clone
      workspaces:
        - name: output
          workspace: shared-code-workspace
      params:
        - name: url
          value: $(params.repo-url)
        - name: revision
          value: $(params.branch-name)
    - name: e2e-test-run
      taskRef:
        name: e2e-task
      workspaces:
        - name: shared-code-workspace
          workspace: shared-code-workspace
      runAfter:
        - fetch-source
      params:
        - name: SOURCE_ARTIFACT
          value: $(params.SOURCE_ARTIFACT)
        - name: HTTP_PROXY
          value: $(params.e2e_proxy)
        - name: E2E_USER
          value: $(params.E2E_USER)
        - name: E2E_PASSWORD
          value: $(params.E2E_PASSWORD)
        - name: STAGE_ACTUAL_HOSTNAME
          value: $(params.STAGE_ACTUAL_HOSTNAME)
        - name: HCC_ENV_URL
          value: $(params.HCC_ENV_URL)
        - name: PROXY_ROUTES
          value: $(params.proxy-routes)
        - name: e2e-tests-script
          value: $(params.e2e-tests-script)
